HasN
====




.. toctree::
   :maxdepth: 3
   :titlesonly:


   HasN/NonPersistedNodeError

   

   

   

   

   

   

   

   

   

   

   HasN/ClassMethods

   HasN/Association




Constants
---------





Files
-----



  * lib/neo4j/active_node/has_n.rb:2

  * lib/neo4j/active_node/has_n/association.rb:5





Methods
-------


**#association_cache**
  Returns the current association cache. It is in the format
  { :association_name => { :hash_of_cypher_string => [collection] }}

  .. hidden-code-block:: ruby

     def association_cache
       @association_cache ||= {}
     end


**#association_instance_fetch**
  

  .. hidden-code-block:: ruby

     def association_instance_fetch(cypher_string, association_obj, &block)
       association_instance_get(cypher_string, association_obj) || association_instance_set(cypher_string, block.call, association_obj)
     end


**#association_instance_get**
  Returns the specified association instance if it responds to :loaded?, nil otherwise.

  .. hidden-code-block:: ruby

     def association_instance_get(cypher_string, association_obj)
       return if association_cache.nil? || association_cache.empty?
       lookup_obj = cypher_hash(cypher_string)
       reflection = association_reflection(association_obj)
       return if reflection.nil?
       association_cache[reflection.name] ? association_cache[reflection.name][lookup_obj] : nil
     end


**#association_instance_get_by_reflection**
  

  .. hidden-code-block:: ruby

     def association_instance_get_by_reflection(reflection_name)
       association_cache[reflection_name]
     end


**#association_instance_set**
  Caches an association result. Unlike ActiveRecord, which stores results in @association_cache using { :association_name => [collection_result] },
  ActiveNode stores it using { :association_name => { :hash_string_of_cypher => [collection_result] }}.
  This is necessary because an association name by itself does not take into account :where, :limit, :order, etc,... so it's prone to error.

  .. hidden-code-block:: ruby

     def association_instance_set(cypher_string, collection_result, association_obj)
       return collection_result if Neo4j::Transaction.current
       cache_key = cypher_hash(cypher_string)
       reflection = association_reflection(association_obj)
       return if reflection.nil?
       if @association_cache[reflection.name]
         @association_cache[reflection.name][cache_key] = collection_result
       else
         @association_cache[reflection.name] = {cache_key => collection_result}
       end
       collection_result
     end


**#association_query_proxy**
  

  .. hidden-code-block:: ruby

     def association_query_proxy(name, options = {})
       self.class.association_query_proxy(name, {start_object: self}.merge(options))
     end


**#association_reflection**
  

  .. hidden-code-block:: ruby

     def association_reflection(association_obj)
       self.class.reflect_on_association(association_obj.name)
     end


**#clear_association_cache**
  Clears out the association cache.

  .. hidden-code-block:: ruby

     def clear_association_cache #:nodoc:
       association_cache.clear if _persisted_obj
     end


**#cypher_hash**
  Uses the cypher generated by a QueryProxy object, complete with params, to generate a basic non-cryptographic hash
  for use in @association_cache.

  .. hidden-code-block:: ruby

     def cypher_hash(cypher_string)
       cypher_string.hash.abs
     end


**#validate_persisted_for_association!**
  

  .. hidden-code-block:: ruby

     def validate_persisted_for_association!
       fail(Neo4j::ActiveNode::HasN::NonPersistedNodeError, 'Unable to create relationship with non-persisted nodes') unless self._persisted_obj
     end





